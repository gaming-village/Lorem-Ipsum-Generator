import React, { useEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';

import Game from '../Game';
import POPUP_DATA, { PopupInfo } from '../data/popup-data';
import { getElem, Point, randInt, roundNum, Vector } from '../utils';

import "../css/pages/malware.css";
import { Link } from 'react-router-dom';

let screenPos = new Point(0, 0);
const screenBounds = 150;
const moveScreen = (translation: Point): void => {
   screenPos = screenPos.add(translation);

   // Keep the screen within the bounds
   if (screenPos.x <= -screenBounds) {
      screenPos.x = -screenBounds;
   } else if (screenPos.x >= screenBounds) {
      screenPos.x = screenBounds;
   }
   if (screenPos.y <= -screenBounds) {
      screenPos.y = -screenBounds;
   } else if (screenPos.y >= screenBounds) {
      screenPos.y = screenBounds;
   }

   const main = getElem("main");
   main.style.left = `calc(50% + ${screenPos.x}px)`;
   main.style.top = `calc(50% + ${screenPos.y}px)`;
}

const findPopupWithName = (name: string): PopupInfo => {
   for (const popup of POPUP_DATA) {
      if (popup.name === name) {
         return popup;
      }
   }
   throw new Error(`Couldn't find popup with name of '${name}'!`);
}

const getUnlockedPopups = (): Array<PopupInfo> => {
   let unlockedPopups = new Array<PopupInfo>();
   for (const popup of POPUP_DATA) {
      if (popup.isUnlocked) unlockedPopups.push(popup);
   }
   return unlockedPopups;
}

interface TextEffectInfo {
   /** Origin point */
   displayPos: {
      top: number;
      left: number;
   }
   position: Point;
   velocity: Vector;
   elem: HTMLElement;
   age: number;
}
const TEXT_EFFECT_CHARS = "!@#$%^&*()".split("");
const textEffects = new Array<TextEffectInfo>();
const createTextEffects = (popup: PopupInfo): void => {
   const count = randInt(10, 21);
   for (let i = 0; i < count; i++) {
      const textEffect = document.createElement("div");
      textEffect.className = "text-effect";
      textEffect.innerHTML = TEXT_EFFECT_CHARS[Math.floor(Math.random() * TEXT_EFFECT_CHARS.length)];
      document.body.appendChild(textEffect);

      // Position them
      textEffect.style.top = `calc(50% + ${popup.displayPos.top}rem)`;
      textEffect.style.left = `calc(50% + ${popup.displayPos.left}rem)`;

      // Give them a random colour (green/red)
      if (Math.random() < 0.8) {
         textEffect.style.color = "#00ff00";
      } else {
         textEffect.style.color = "#ff0000";
      }
      
      const vel = new Vector(
         randInt(2, 10),
         randInt(0, 360)
      );
      const textEffectInfo: TextEffectInfo = {
         displayPos: popup.displayPos,
         position: new Point(0, 0),
         velocity: vel,
         elem: textEffect,
         age: 0
      };
      textEffects.push(textEffectInfo);
   }
}

const showTooltips = (popup: PopupInfo) => {
   {
      const previousTooltips = document.getElementById("tooltips");
      if (previousTooltips !== null) {
         ReactDOM.unmountComponentAtNode(previousTooltips.parentElement!);
      }
   }

   const style: React.CSSProperties = {
      top: `calc(50% + ${popup.displayPos.top}rem + ${screenPos.y}px - 24px)`,
      left: `calc(50% + ${popup.displayPos.left}rem + ${screenPos.x}px)`
   };

   const canAfford = Game.packets >= popup.cost;
   const tooltips = <div style={style} id="tooltips" className={popup.isUnlocked ? "unlocked" : undefined}>
      <div className="formatter cf">
         <p className="name">{popup.name}</p>
         {!popup.isUnlocked ? <div className={`cost${canAfford ? " can-afford" : ""}`}>{popup.cost}</div> : undefined}
      </div>
      <p className="unlock-type">({popup.isUnlocked ? "UNLOCKED" : "LOCKED"})</p>

      <p className="description">{popup.description}</p>
      <p className="flavour-text">{popup.flavourText}</p>
   </div>;

   ReactDOM.render(tooltips, document.getElementById("tooltip-container"));
}
const hideTooltips = () => {
   const tooltips = document.getElementById("tooltips");
   if (tooltips !== null) {
      tooltips.classList.add("hiding");

      const ANIM_DURATION = 250;
      setTimeout(() => {
         if (tooltips.parentElement !== null) {
            ReactDOM.unmountComponentAtNode(tooltips.parentElement!);
         }
      }, ANIM_DURATION);
   }
}

interface PopupPreviewProps {
   popup: PopupInfo;
   buyFunc: (popup: PopupInfo) => void;
}
const PopupPreview = ({ popup, buyFunc }: PopupPreviewProps) => {
   const ref = useRef(null);

   useEffect(() => {
      (ref.current! as HTMLElement).style.top = `calc(50% + ${popup.displayPos.top}rem)`;
      (ref.current! as HTMLElement).style.left = `calc(50% + ${popup.displayPos.left}rem)`;
   }, [popup.displayPos.left, popup.displayPos.top]);

   let imgSrc!: string;
   try {
      imgSrc = require("../images/popup-icons/" + popup.iconSrc).default;
   } catch {
      imgSrc = require("../images/icons/questionmark.png").default;
   }

   const canBuy = Game.packets >= popup.cost;

   return <div ref={ref} onMouseOver={() => showTooltips(popup)} onMouseOut={hideTooltips} onClick={!popup.isUnlocked && canBuy ? () => buyFunc(popup) : undefined} className={`popup${popup.isUnlocked ? " unlocked" : ""}`}>
      <div className="title">{popup.name}</div>
      <img alt={popup.iconSrc} src={imgSrc} />
   </div>;
}

const getViewablePopups = (unlockedPopups: Array<PopupInfo>): Array<PopupInfo> => {
   let unlockedNames = new Array<string>();
   for (const popup of unlockedPopups) {
      unlockedNames.push(popup.name);
   }

   let viewablePopups = new Array<PopupInfo>();
   for (const popup of POPUP_DATA) {
      if (popup.children.length === 0) {
         viewablePopups.push(popup);
         continue;
      }
      for (const childName of popup.children) {
         if (unlockedNames.indexOf(childName) !== -1) {
            viewablePopups.push(popup);
            break;
         }
      }
   }
   return viewablePopups;
}

interface ConnectionProps {
   start: PopupInfo;
   end: PopupInfo;
}
const Connection = ({ start, end }: ConnectionProps) => {
   const angle = Math.atan2(-(start.displayPos.top - end.displayPos.top), -(start.displayPos.left - end.displayPos.left));
   const length = Math.sqrt(Math.pow(start.displayPos.left - end.displayPos.left, 2) + Math.pow(start.displayPos.top - end.displayPos.top, 2));

   const style: React.CSSProperties = {
      width: length + "rem",
      transform: `rotate(${angle}rad)`,
      top: `calc(50% + ${start.displayPos.top}rem)`,
      left: `calc(50% + ${start.displayPos.left}rem)`
   };

   return <div style={style} className={`connection${start.isUnlocked && end.isUnlocked ? " unlocked" : ""}`}></div>;
}

const Malware = () => {
   const [unlockedPopups, setUnlockedPopups] = useState<Array<PopupInfo>>(getUnlockedPopups());

   useEffect(() => {
      const mouseDown = (): void => {
         const e = window.event as MouseEvent;

         // Don't move the screen if the user is clicking something
         const path = e.composedPath();
         if (path[path.length - 1] !== window) return;

         let previousTranslation: Point = new Point(e.clientX, e.clientY);
         const mouseMove = (): void => {
            const e2 = window.event as MouseEvent;

            // Move the screen
            const TRANSLATION_MULTIPLIER = 0.5;
            const translation = new Point(
               (e2.clientX - previousTranslation.x) * TRANSLATION_MULTIPLIER,
               (e2.clientY - previousTranslation.y) * TRANSLATION_MULTIPLIER
            );
            moveScreen(translation);

            previousTranslation = new Point(e2.clientX, e2.clientY);;
         }

         const mouseUp = (): void => {
            window.removeEventListener("mousemove", mouseMove);
            window.removeEventListener("mouseup", mouseUp);
         }

         window.addEventListener("mousemove", mouseMove);
         window.addEventListener("mouseup", mouseUp);
      }

      window.addEventListener("mousedown", mouseDown);

      const updateTextEffects = (): void => {
         const textEffectsToRemove = new Array<TextEffectInfo>();
         
         /** Lifetime in seconds */
         const LIFETIME = 0.5;

         for (const textEffect of textEffects) {
            textEffect.position = textEffect.position.add(textEffect.velocity.convertToPoint());

            // Update their position
            textEffect.elem.style.left = `calc(50% + ${textEffect.displayPos.left}rem + ${textEffect.position.x}px)`;
            textEffect.elem.style.top = `calc(50% + ${textEffect.displayPos.top}rem + ${textEffect.position.y}px)`;

            // Chance to 'glitch' their innerHTML
            if (Math.random() < 0.6) {
               textEffect.elem.innerHTML = TEXT_EFFECT_CHARS[Math.floor(Math.random() * TEXT_EFFECT_CHARS.length)];
            }

            // Fade out over time
            textEffect.elem.style.opacity = (1 - textEffect.age / Game.tps / LIFETIME).toString();
            
            // Remove old text effects
            textEffect.age++;
            if (textEffect.age >= Game.tps * LIFETIME) {
               textEffectsToRemove.push(textEffect);
            }
         }

         for (const oldTextEffect of textEffectsToRemove) {
            oldTextEffect.elem.remove();
            textEffects.splice(textEffects.indexOf(oldTextEffect), 1);
         }
      };

      Game.createRenderListener(updateTextEffects);

      return () => {
         window.removeEventListener("mousedown", mouseDown);

         while (textEffects.length > 0) {
            textEffects[0].elem.remove();
            textEffects.splice(0, 1);
         }

         Game.removeRenderListener(updateTextEffects);
      }
   }, []);

   const unlockPopup = (popup: PopupInfo): void => {
      popup.isUnlocked = true;
      Game.packets -= popup.cost;

      hideTooltips();
      showTooltips(popup);

      // Create the green wiggly text
      createTextEffects(popup);

      const newUnlockedPopupsArr = unlockedPopups.slice();
      newUnlockedPopupsArr.push(popup);
      setUnlockedPopups(newUnlockedPopupsArr);
   }

   const packetCount = Game.packets;

   const content = new Array<JSX.Element>();
   const viewablePopups = getViewablePopups(unlockedPopups);
   let key = 0;
   for (let i = 0; i < viewablePopups.length; i++) {
      const popup = viewablePopups[i];
      if (popup.children.length > 0) {
         for (const childName of popup.children) {
            const child = findPopupWithName(childName);
            content.push(
               <Connection key={key++} start={popup} end={child} />
            );
         }
      }
      content.push(
         <PopupPreview key={key++} popup={popup} buyFunc={unlockPopup} />
      );
   }

   return <div id="malware">
      <h2>{roundNum(packetCount)} Packets</h2>

      <div id="main">
         {content}
      </div>

      <div id="tooltip-container"></div>

      <Link to="/">
         <button className="back-button">Back</button>
      </Link>
   </div>;
}

export default Malware