import React, { useEffect, useRef, useState } from 'react';
import POPUP_DATA, { PopupInfo } from '../data/popup-data';
import Game from '../Game';

import "../css/pages/malware.css";
import ReactDOM from 'react-dom';
import { Point, randInt, roundNum, Vector } from '../utils';

const findPopupWithName = (name: string): PopupInfo => {
   for (const popup of POPUP_DATA) {
      if (popup.name === name) {
         return popup;
      }
   }
   throw new Error(`Couldn't find popup with name of '${name}'!`);
}

const getUnlockedPopups = (): Array<PopupInfo> => {
   let unlockedPopups = new Array<PopupInfo>();
   for (const popup of POPUP_DATA) {
      if (popup.isUnlocked) unlockedPopups.push(popup);
   }
   return unlockedPopups;
}

interface TextEffectInfo {
   /** Origin point */
   displayPos: {
      top: number;
      left: number;
   }
   position: Point;
   velocity: Vector;
   elem: HTMLElement;
   age: number;
}
const TEXT_EFFECT_CHARS = "!@#$%^&*()".split("");
const textEffects = new Array<TextEffectInfo>();
const createTextEffects = (popup: PopupInfo): void => {
   const count = randInt(10, 21);
   for (let i = 0; i < count; i++) {
      const textEffect = document.createElement("div");
      textEffect.className = "text-effect";
      textEffect.innerHTML = TEXT_EFFECT_CHARS[Math.floor(Math.random() * TEXT_EFFECT_CHARS.length)];
      document.body.appendChild(textEffect);

      // Give them a random colour (green/red)
      if (Math.random() < 0.8) {
         textEffect.style.color = "#00ff00";
      } else {
         textEffect.style.color = "#ff0000";
      }
      
      const vel = new Vector(
         randInt(2, 10),
         randInt(0, 360)
      );
      const textEffectInfo: TextEffectInfo = {
         displayPos: popup.displayPos,
         position: new Point(0, 0),
         velocity: vel,
         elem: textEffect,
         age: 0
      };
      textEffects.push(textEffectInfo);
   }
}

const showTooltips = (popup: PopupInfo) => {
   const style: React.CSSProperties = {
      top: `calc(50% + ${popup.displayPos.top}rem - 24px)`,
      left: `calc(50% + ${popup.displayPos.left}rem)`
   };

   const tooltips = <div style={style} id="tooltips" className={popup.isUnlocked ? "unlocked" : undefined}>
      <div className="formatter cf">
         <p className="name">{popup.name}</p>
         {!popup.isUnlocked ? <div className="cost">{popup.cost}</div> : undefined}
      </div>
      <p className="unlock-type">({popup.isUnlocked ? "UNLOCKED" : "LOCKED"})</p>

      <p className="description">{popup.description}</p>
      <p className="flavour-text">{popup.flavourText}</p>
   </div>;

   ReactDOM.render(tooltips, document.getElementById("tooltip-container"));
}
const hideTooltips = () => {
   const tooltips = document.getElementById("tooltips");
   if (tooltips !== null) {
      ReactDOM.unmountComponentAtNode(tooltips.parentElement!);
   }
}

interface PopupPreviewProps {
   popup: PopupInfo;
   buyFunc: (popup: PopupInfo) => void;
}
const PopupPreview = ({ popup, buyFunc }: PopupPreviewProps) => {
   const ref = useRef(null);

   useEffect(() => {
      (ref.current! as HTMLElement).style.top = `calc(50% + ${popup.displayPos.top}rem)`;
      (ref.current! as HTMLElement).style.left = `calc(50% + ${popup.displayPos.left}rem)`;
   }, [popup.displayPos.left, popup.displayPos.top]);

   let imgSrc!: string;
   try {
      imgSrc = require("../images/popup-icons/" + popup.iconSrc).default;
   } catch {
      imgSrc = require("../images/icons/questionmark.png").default;
   }

   return <div ref={ref} onMouseOver={() => showTooltips(popup)} onMouseOut={hideTooltips} onClick={!popup.isUnlocked ? () => buyFunc(popup) : undefined} className={`popup${popup.isUnlocked ? " unlocked" : ""}`}>
      <div className="title">{popup.name}</div>
      <img alt={popup.iconSrc} src={imgSrc} />
   </div>;
}

const getViewablePopups = (unlockedPopups: Array<PopupInfo>): Array<PopupInfo> => {
   let unlockedNames = new Array<string>();
   for (const popup of unlockedPopups) {
      unlockedNames.push(popup.name);
   }

   let viewablePopups = new Array<PopupInfo>();
   for (const popup of POPUP_DATA) {
      if (popup.children.length === 0) {
         viewablePopups.push(popup);
         continue;
      }
      for (const childName of popup.children) {
         if (unlockedNames.indexOf(childName) !== -1) {
            viewablePopups.push(popup);
            break;
         }
      }
   }
   return viewablePopups;
}

interface ConnectionProps {
   start: PopupInfo;
   end: PopupInfo;
}
const Connection = ({ start, end }: ConnectionProps) => {
   const angle = Math.atan2(-(start.displayPos.top - end.displayPos.top), -(start.displayPos.left - end.displayPos.left));
   const length = Math.sqrt(Math.pow(start.displayPos.left - end.displayPos.left, 2) + Math.pow(start.displayPos.top - end.displayPos.top, 2));

   const style: React.CSSProperties = {
      width: length + "rem",
      transform: `rotate(${angle}rad)`,
      top: `calc(50% + ${start.displayPos.top}rem)`,
      left: `calc(50% + ${start.displayPos.left}rem)`
   };

   return <div style={style} className={`connection${start.isUnlocked && end.isUnlocked ? " unlocked" : ""}`}></div>;
}

const Malware = () => {
   const [unlockedPopups, setUnlockedPopups] = useState<Array<PopupInfo>>(getUnlockedPopups());

   useEffect(() => {
      const updateTextEffects = (): void => {
         const textEffectsToRemove = new Array<TextEffectInfo>();
         
         /** Lifetime in seconds */
         const LIFETIME = 0.5;
         for (const textEffect of textEffects) {
            textEffect.position = textEffect.position.add(textEffect.velocity.convertToPoint());

            // Update their position
            textEffect.elem.style.left = `calc(50% + ${textEffect.displayPos.left}rem + ${textEffect.position.x}px)`;
            textEffect.elem.style.top = `calc(50% + ${textEffect.displayPos.top}rem + ${textEffect.position.y}px)`;

            // Chance to 'glitch' their innerHTML
            if (Math.random() < 0.6) {
               textEffect.elem.innerHTML = TEXT_EFFECT_CHARS[Math.floor(Math.random() * TEXT_EFFECT_CHARS.length)];
            }

            // Fade out over time
            textEffect.elem.style.opacity = (1 - textEffect.age / Game.tps / LIFETIME).toString();
            
            // Remove old text effects
            textEffect.age++;
            if (textEffect.age >= Game.tps * LIFETIME) {
               textEffectsToRemove.push(textEffect);
            }
         }

         for (const oldTextEffect of textEffectsToRemove) {
            oldTextEffect.elem.remove();
            textEffects.splice(textEffects.indexOf(oldTextEffect));
         }
      };

      Game.createRenderListener(updateTextEffects);

      return () => {
         while (textEffects.length > 0) {
            textEffects[0].elem.remove();
            textEffects.splice(0, 1);
         }

         Game.removeRenderListener(updateTextEffects);
      }
   }, []);

   const unlockPopup = (popup: PopupInfo): void => {
      popup.isUnlocked = true;
      Game.lorem -= popup.cost;

      hideTooltips();
      showTooltips(popup);

      // Create the green wiggly text
      createTextEffects(popup);

      const newUnlockedPopupsArr = unlockedPopups.slice();
      newUnlockedPopupsArr.push(popup);
      setUnlockedPopups(newUnlockedPopupsArr);
   }

   const packetCount = Game.packets;

   const content = new Array<JSX.Element>();
   const viewablePopups = getViewablePopups(unlockedPopups);
   let key = 0;
   for (let i = 0; i < viewablePopups.length; i++) {
      const popup = viewablePopups[i];
      if (popup.children.length > 0) {
         for (const childName of popup.children) {
            const child = findPopupWithName(childName);
            content.push(
               <Connection key={key++} start={popup} end={child} />
            );
         }
      }
      content.push(
         <PopupPreview key={key++} popup={popup} buyFunc={unlockPopup} />
      );
   }

   return <div id="malware">
      <h2>{roundNum(packetCount)} Packets</h2>

      {content}

      <div id="tooltip-container"></div>
   </div>;
}

export default Malware